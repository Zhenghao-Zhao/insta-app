// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: post.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (content, user_id)
    VALUES ($1, $2)
RETURNING
    id, uid, created_at, content, user_id
`

type CreatePostParams struct {
	Content *string `json:"content"`
	UserID  int32   `json:"user_id"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (*Post, error) {
	row := q.db.QueryRow(ctx, createPost, arg.Content, arg.UserID)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.Content,
		&i.UserID,
	)
	return &i, err
}

const deletePostByPostUid = `-- name: DeletePostByPostUid :exec
DELETE FROM posts p
WHERE p.uid = $1
`

func (q *Queries) DeletePostByPostUid(ctx context.Context, postUid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePostByPostUid, postUid)
	return err
}

const getPaginatedPostsByUserUid = `-- name: GetPaginatedPostsByUserUid :many
WITH images AS (
    SELECT
        p.id AS post_id,
        json_agg(i.uid) AS image_uids
    FROM
        posts p
        LEFT JOIN public.post_images i ON p.id = i.post_id
    GROUP BY
        p.id
)
SELECT
    p.id AS post_id,
    p.uid AS post_uid,
    p.user_id AS owner_id,
    p.created_at AS created_at,
    p.content AS content,
    COALESCE(t1.like_count, 0) AS like_count,
    COALESCE(t2.comment_count, 0) AS comment_count,
    (l.id IS NOT NULL)::bool AS has_liked,
    i.image_uids AS image_uids,
    u.uid AS owner_uid,
    u.username AS owner_username,
    profiles.name AS owner_name,
    profiles.profile_image AS owner_profile_image,
    (f.id IS NOT NULL)::bool AS owner_is_following
FROM
    posts p
    LEFT JOIN users u ON p.user_id = u.id
    LEFT JOIN profiles ON u.id = profiles.user_id
    LEFT JOIN (
        SELECT
            post_id,
            COUNT(*) AS like_count
        FROM
            post_likes
        GROUP BY
            post_id) t1 ON p.id = t1.post_id
    LEFT JOIN (
        SELECT
            post_id,
            COUNT(*) AS comment_count
        FROM
            comments
        GROUP BY
            post_id) t2 ON p.id = t2.post_id
    LEFT JOIN post_likes l ON l.post_id = p.id
        AND l.user_id = $1
    LEFT JOIN images i ON i.post_id = p.id
    LEFT JOIN followers f ON f.followee_id = p.user_id
        AND f.follower_id = $1
WHERE
    u.uid = $2
ORDER BY
    p.created_at DESC OFFSET $3
LIMIT $4
`

type GetPaginatedPostsByUserUidParams struct {
	MyUserID int32     `json:"my_user_id"`
	UserUid  uuid.UUID `json:"user_uid"`
	Offset   int32     `json:"offset"`
	Limit    int32     `json:"limit"`
}

type GetPaginatedPostsByUserUidRow struct {
	PostID            int32              `json:"post_id"`
	PostUid           uuid.UUID          `json:"post_uid"`
	OwnerID           int32              `json:"owner_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Content           *string            `json:"content"`
	LikeCount         int64              `json:"like_count"`
	CommentCount      int64              `json:"comment_count"`
	HasLiked          bool               `json:"has_liked"`
	ImageUids         []byte             `json:"image_uids"`
	OwnerUid          uuid.UUID          `json:"owner_uid"`
	OwnerUsername     *string            `json:"owner_username"`
	OwnerName         *string            `json:"owner_name"`
	OwnerProfileImage uuid.UUID          `json:"owner_profile_image"`
	OwnerIsFollowing  bool               `json:"owner_is_following"`
}

func (q *Queries) GetPaginatedPostsByUserUid(ctx context.Context, arg GetPaginatedPostsByUserUidParams) ([]*GetPaginatedPostsByUserUidRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedPostsByUserUid,
		arg.MyUserID,
		arg.UserUid,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPaginatedPostsByUserUidRow
	for rows.Next() {
		var i GetPaginatedPostsByUserUidRow
		if err := rows.Scan(
			&i.PostID,
			&i.PostUid,
			&i.OwnerID,
			&i.CreatedAt,
			&i.Content,
			&i.LikeCount,
			&i.CommentCount,
			&i.HasLiked,
			&i.ImageUids,
			&i.OwnerUid,
			&i.OwnerUsername,
			&i.OwnerName,
			&i.OwnerProfileImage,
			&i.OwnerIsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedPostsByUsername = `-- name: GetPaginatedPostsByUsername :many
WITH images AS (
    SELECT
        p.id AS post_id,
        json_agg(i.uid) AS image_uids
    FROM
        posts p
        LEFT JOIN public.post_images i ON p.id = i.post_id
    GROUP BY
        p.id
)
SELECT
    p.id AS post_id,
    p.uid AS post_uid,
    p.user_id AS owner_id,
    p.created_at AS created_at,
    p.content AS content,
    COALESCE(t1.like_count, 0) AS like_count,
    COALESCE(t2.comment_count, 0) AS comment_count,
    (l.id IS NOT NULL)::bool AS has_liked,
    i.image_uids AS image_uids,
    u.uid AS owner_uid,
    u.username AS owner_username,
    profiles.name AS owner_name,
    profiles.profile_image AS owner_profile_image,
    (f.id IS NOT NULL)::bool AS owner_is_following
FROM
    posts p
    LEFT JOIN users u ON p.user_id = u.id
    LEFT JOIN profiles ON u.id = profiles.user_id
    LEFT JOIN (
        SELECT
            post_id,
            COUNT(*) AS like_count
        FROM
            post_likes
        GROUP BY
            post_id) t1 ON p.id = t1.post_id
    LEFT JOIN (
        SELECT
            post_id,
            COUNT(*) AS comment_count
        FROM
            comments
        GROUP BY
            post_id) t2 ON p.id = t2.post_id
    LEFT JOIN post_likes l ON l.post_id = p.id
        AND l.user_id = $1
    LEFT JOIN images i ON i.post_id = p.id
    LEFT JOIN followers f ON f.followee_id = p.user_id
        AND f.follower_id = $1
WHERE
    u.username = $2
ORDER BY
    p.created_at DESC OFFSET $3
LIMIT $4
`

type GetPaginatedPostsByUsernameParams struct {
	MyUserID   int32  `json:"my_user_id"`
	MyUsername string `json:"my_username"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

type GetPaginatedPostsByUsernameRow struct {
	PostID            int32              `json:"post_id"`
	PostUid           uuid.UUID          `json:"post_uid"`
	OwnerID           int32              `json:"owner_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Content           *string            `json:"content"`
	LikeCount         int64              `json:"like_count"`
	CommentCount      int64              `json:"comment_count"`
	HasLiked          bool               `json:"has_liked"`
	ImageUids         []byte             `json:"image_uids"`
	OwnerUid          uuid.UUID          `json:"owner_uid"`
	OwnerUsername     *string            `json:"owner_username"`
	OwnerName         *string            `json:"owner_name"`
	OwnerProfileImage uuid.UUID          `json:"owner_profile_image"`
	OwnerIsFollowing  bool               `json:"owner_is_following"`
}

func (q *Queries) GetPaginatedPostsByUsername(ctx context.Context, arg GetPaginatedPostsByUsernameParams) ([]*GetPaginatedPostsByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedPostsByUsername,
		arg.MyUserID,
		arg.MyUsername,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPaginatedPostsByUsernameRow
	for rows.Next() {
		var i GetPaginatedPostsByUsernameRow
		if err := rows.Scan(
			&i.PostID,
			&i.PostUid,
			&i.OwnerID,
			&i.CreatedAt,
			&i.Content,
			&i.LikeCount,
			&i.CommentCount,
			&i.HasLiked,
			&i.ImageUids,
			&i.OwnerUid,
			&i.OwnerUsername,
			&i.OwnerName,
			&i.OwnerProfileImage,
			&i.OwnerIsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostUID = `-- name: GetPostByPostUID :one
WITH images AS (
    SELECT
        p.id AS post_id,
        json_agg(i.uid) AS image_uids
    FROM
        posts p
        LEFT JOIN public.post_images i ON p.id = i.post_id
    GROUP BY
        p.id
)
SELECT
    p.id AS post_id,
    p.uid AS post_uid,
    p.user_id AS owner_id,
    p.created_at AS created_at,
    p.content AS content,
    COALESCE(t1.like_count, 0) AS like_count,
    COALESCE(t2.comment_count, 0) AS comment_count,
    (l.id IS NOT NULL)::bool AS has_liked,
    i.image_uids AS image_uids,
    u.uid AS owner_uid,
    u.username AS owner_username,
    profiles.name AS owner_name,
    profiles.profile_image AS owner_profile_image,
    (f.id IS NOT NULL)::bool AS owner_is_following
FROM
    posts p
    LEFT JOIN users u ON p.user_id = u.id
    LEFT JOIN profiles ON u.id = profiles.user_id
    LEFT JOIN (
        SELECT
            post_id,
            COUNT(*) AS like_count
        FROM
            post_likes
        GROUP BY
            post_id) t1 ON p.id = t1.post_id
    LEFT JOIN (
        SELECT
            post_id,
            COUNT(*) AS comment_count
        FROM
            comments
        GROUP BY
            post_id) t2 ON p.id = t2.post_id
    LEFT JOIN post_likes l ON l.post_id = p.id
    LEFT JOIN images i ON i.post_id = p.id
        AND l.user_id = $1
    LEFT JOIN followers f ON f.followee_id = p.user_id
        AND f.follower_id = $1
WHERE
    p.uid = $2
`

type GetPostByPostUIDParams struct {
	MyUserID int32     `json:"my_user_id"`
	PostUid  uuid.UUID `json:"post_uid"`
}

type GetPostByPostUIDRow struct {
	PostID            int32              `json:"post_id"`
	PostUid           uuid.UUID          `json:"post_uid"`
	OwnerID           int32              `json:"owner_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Content           *string            `json:"content"`
	LikeCount         int64              `json:"like_count"`
	CommentCount      int64              `json:"comment_count"`
	HasLiked          bool               `json:"has_liked"`
	ImageUids         []byte             `json:"image_uids"`
	OwnerUid          uuid.UUID          `json:"owner_uid"`
	OwnerUsername     *string            `json:"owner_username"`
	OwnerName         *string            `json:"owner_name"`
	OwnerProfileImage uuid.UUID          `json:"owner_profile_image"`
	OwnerIsFollowing  bool               `json:"owner_is_following"`
}

func (q *Queries) GetPostByPostUID(ctx context.Context, arg GetPostByPostUIDParams) (*GetPostByPostUIDRow, error) {
	row := q.db.QueryRow(ctx, getPostByPostUID, arg.MyUserID, arg.PostUid)
	var i GetPostByPostUIDRow
	err := row.Scan(
		&i.PostID,
		&i.PostUid,
		&i.OwnerID,
		&i.CreatedAt,
		&i.Content,
		&i.LikeCount,
		&i.CommentCount,
		&i.HasLiked,
		&i.ImageUids,
		&i.OwnerUid,
		&i.OwnerUsername,
		&i.OwnerName,
		&i.OwnerProfileImage,
		&i.OwnerIsFollowing,
	)
	return &i, err
}
